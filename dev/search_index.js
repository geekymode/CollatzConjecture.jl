var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"#CollatzConjecture","page":"Home","title":"CollatzConjecture","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CollatzConjecture.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for CollatzConjecture!","category":"page"},{"location":"#What-is-CollatzConjecture.jl?","page":"Home","title":"What is CollatzConjecture.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CollatzConjecture is a formal TBD.","category":"page"},{"location":"#Collatz-Conjecture-Visualizations","page":"Home","title":"Collatz Conjecture Visualizations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Collatz Conjecture Visualization package! This package provides tools for exploring and visualizing the famous Collatz conjecture through various mathematical and artistic representations.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Collatz conjecture is one of the most famous unsolved problems in mathematics. Starting with any positive integer n:","category":"page"},{"location":"","page":"Home","title":"Home","text":"If n is even, divide it by 2\nIf n is odd, multiply by 3 and add 1\nRepeat until you reach 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides multiple ways to visualize these sequences and explore their mathematical properties.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a basic visualization of Collatz sequences using the default parameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CollatzConjecture\nusing CairoMakie\n\nCairoMakie.activate!()\n\n# Create and display the visualization\nfig = create_collatz_visualization(n=50, print_numbers=true)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nThis is still under active development.","category":"page"},{"location":"#Resources-for-getting-started","page":"Home","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are a few ways to get started with CollatzConjecture:","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Open a Julia session and enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"CollatzConjecture\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"this will download the package and all the necessary dependencies for you. Next you can import the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"and you are ready to go.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using CollatzConjecture","category":"page"},{"location":"#CollatzConjecture.astro_intensity-NTuple{5, Any}","page":"Home","title":"CollatzConjecture.astro_intensity","text":"astro_intensity(l, s, r, h, g)\n\nCalculate RGB color values for astronomical intensity visualization.\n\nThis function computes RGB color values based on astronomical parameters using a  mathematical transformation that combines lightness, saturation, and spectral  characteristics. The calculation involves trigonometric functions and matrix-like  operations to produce realistic color representations for astronomical data.\n\nArguments\n\nl::Real: Lightness parameter (typically in range [0,1])\ns::Real: Saturation parameter \nr::Real: Radial or spectral parameter\nh::Real: Hue amplitude parameter\ng::Real: Gamma correction exponent\n\nReturns\n\nVector{Float64}: RGB color values as a 3-element vector [R, G, B], clamped to [0,1]\n\nExamples\n\njulia> astro_intensity(0.5, 1.0, 0.2, 0.8, 2.0)\n3-element Vector{Float64}:\n 0.4123\n 0.2847\n 0.6891\n\njulia> astro_intensity(0.8, 0.5, 0.1, 1.2, 1.5)\n3-element Vector{Float64}:\n 0.7234\n 0.5678\n 0.8901\n\njulia> astro_intensity(0.2, 2.0, 0.5, 0.6, 1.8)\n3-element Vector{Float64}:\n 0.1456\n 0.0892\n 0.3278\n\nNotes\n\nThe function uses specific transformation coefficients optimized for astronomical  color representation:\n\nRed channel: -0.14861 * cos(ψ) + 1.78277 * sin(ψ)\nGreen channel: -0.29227 * cos(ψ) - 0.90649 * sin(ψ)  \nBlue channel: 1.97294 * cos(ψ)\n\nWhere ψ = 2π * (s/3 + r * l) represents the phase angle for color calculation.\n\nAll output values are clamped to the valid color range [0,1].\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.calculate_stopping_times-Tuple{Int64}","page":"Home","title":"CollatzConjecture.calculate_stopping_times","text":"calculate_stopping_times(max_n::Int)\n\nCalculate stopping times for all integers from 1 to max_n and return valid results.\n\nThis function computes the Collatz stopping time for each integer in the range [1, max_n] and returns only those numbers that have valid (positive) stopping times, filtering out any that exceed the safety limit or have invalid inputs.\n\nArguments\n\nmax_n::Int: Maximum number to compute stopping times for (computes for range 1:max_n)\n\nReturns\n\nTuple{Vector{Int}, Vector{Int}}: A tuple containing:\nnumbers: Vector of numbers that have valid stopping times\ntimes: Vector of corresponding stopping times (same length as numbers)\n\nExamples\n\n# Calculate stopping times for numbers 1-10\nnumbers, times = calculate_stopping_times(10)\n# numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# times:   [0, 1, 7, 2, 5, 8, 16, 3, 19, 6]\n\n# Calculate for a larger range\nnumbers, times = calculate_stopping_times(100)\nprintln(\"Number with longest stopping time: \", numbers[argmax(times)])\nprintln(\"Maximum stopping time: \", maximum(times))\n\n# Analyze the results\nusing Statistics\nprintln(\"Mean stopping time: \", mean(times))\nprintln(\"Median stopping time: \", median(times))\n\nDetails\n\nThe function processes each number sequentially:\n\nCalls stopping_time(n) for each n in 1:max_n\nFilters results to include only positive stopping times\nReturns parallel arrays of numbers and their corresponding stopping times\n\nOnly numbers with valid stopping times are included in the results:\n\nPositive stopping times (successful convergence to 1)\nExcludes any numbers that return -1 (exceeded step limit)\nExcludes any numbers that return 0 (invalid inputs, though this shouldn't occur for positive integers)\n\nPerformance Considerations\n\nTime complexity: O(maxn × averagestopping_time)\nSpace complexity: O(max_n) for storing results\nMemory efficient: Uses pre-allocated vectors that grow as needed\nProgress tracking: For large ranges, consider adding progress indicators\n\nUse Cases\n\nThis function is particularly useful for:\n\nStatistical analysis of stopping time distributions\nFinding patterns in Collatz behavior across ranges\nIdentifying outliers with unusually long stopping times\nCreating visualizations of stopping time data\nResearch applications studying Collatz conjecture properties\n\nData Analysis Applications\n\n# Find numbers with maximum stopping times\nnumbers, times = calculate_stopping_times(1000)\nmax_indices = findall(==(maximum(times)), times)\nprintln(\"Numbers with maximum stopping time: \", numbers[max_indices])\n\n# Create histogram of stopping times\nusing Plots\nhistogram(times, bins=50, title=\"Distribution of Stopping Times\")\n\n# Find correlation patterns\nscatter(numbers, times, xlabel=\"Number\", ylabel=\"Stopping Time\")\n\nMathematical Insights\n\nThe resulting data can reveal:\n\nDistribution patterns in stopping times\nRecord-breaking sequences (numbers with locally maximum stopping times)\nPower-of-2 patterns (2^k numbers have stopping time k)\nStatistical properties of the Collatz conjecture\n\nSee Also\n\nstopping_time: Calculate stopping time for a single number\ncollatz_sequence: Generate complete Collatz sequences\ncreate_collatz_visualization: Visualize Collatz sequence patterns\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.collatz_angle_path-NTuple{4, Any}","page":"Home","title":"CollatzConjecture.collatz_angle_path","text":"collatz_angle_path(n, e, a, f)\n\nGenerate a Collatz sequence and convert it to an angle-based path in Cartesian coordinates.\n\nThe function generates the Collatz sequence starting from n, reverses it to begin from 1, then calculates radii and angles based on the sequence values to create a geometric path.\n\nArguments\n\nn: Starting number for the Collatz sequence (must be positive integer)\ne: Exponent parameter for radius calculation\na: Angle scaling factor\nf: Angle offset factor (typically used to distinguish even/odd behavior)\n\nReturns\n\nArray of (x, y) coordinate tuples representing the path, starting from origin (0, 0)\n\nDetails\n\nThe path is constructed by:\n\nGenerating the Collatz sequence from n to 1\nReversing the sequence to start from 1\nConverting sequence values to radii using: r = value / (1 + value^e)\nCalculating angles using: angle = a * (f - 2 * (value % 2))\nConverting to Cartesian coordinates using cumulative angles and radii\n\nExamples\n\npath = collatz_angle_path(7, 0.5, π/4, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.collatz_graph","page":"Home","title":"CollatzConjecture.collatz_graph","text":"collatz_graph(range_end = 1000; kwargs...)\n\nCreate a directed graph visualization of Collatz sequences showing the relationships between numbers.\n\nThis function generates Collatz sequences for all numbers from 1 to range_end, extracts the unique vertices and directed edges, and creates a graph visualization using GraphMakie.jl. The resulting graph shows how numbers transition to other numbers following Collatz rules.\n\nArguments\n\nrange_end = 1000: Upper limit of the range (generates sequences for 1:range_end)\n\nKeyword Arguments\n\nVisual Styling\n\nvertex_style = RGBA(44/51, 10/51, 47/255, 0.2): Color and transparency of graph vertices\nedge_style = RGB(38/255, 139/255, 14/17): Color of graph edges\nvertex_size = 2: Size of vertex markers\nedge_width = 0.5: Width of edge lines\n\nLayout and Structure\n\ngraph_layout = \"ClosestPacking\": Layout algorithm (\"ClosestPacking\", \"Spring\", or other)\n\nLabels\n\nshow_labels = false: Whether to show vertex labels with numbers\nlabel_fontsize = 8: Font size for vertex labels (only when show_labels=true)\n\nOutput Control\n\nprint_stats = true: Whether to print detailed statistics about the graph\n\nReturns\n\nTuple{Figure, SimpleDiGraph, Vector{Int}, Vector{Tuple{Int,Int}}}: \nfig: Makie Figure containing the graph visualization\ng: The directed graph object from Graphs.jl\nvertices: Vector of all unique vertices in the graph\nedges: Vector of all directed edges as (source, destination) tuples\n\nExamples\n\n# Create basic Collatz graph for numbers 1-100\nfig, graph, vertices, edges = collatz_graph(100)\n\n# Create labeled graph for small range with custom styling\nfig, graph, vertices, edges = collatz_graph(20,\n    show_labels = true,\n    vertex_size = 8,\n    label_fontsize = 10,\n    edge_width = 1.0\n)\n\n# Create large graph with spring layout\nfig, graph, vertices, edges = collatz_graph(5000,\n    graph_layout = \"Spring\",\n    vertex_style = RGBA(1.0, 0.2, 0.2, 0.3),\n    print_stats = true\n)\n\n# Create minimal graph without statistics\nfig, graph, vertices, edges = collatz_graph(50,\n    print_stats = false,\n    vertex_size = 1,\n    edge_width = 0.3\n)\n\nDetails\n\nThe graph construction process:\n\nSequence Generation: Creates Collatz sequences for all numbers 1 to range_end\nVertex Extraction: Collects all unique numbers that appear in any sequence\nEdge Extraction: Identifies directed transitions (n → next_n) from sequences\nGraph Building: Constructs a directed graph using Graphs.jl\nConnectivity Analysis: Analyzes connected components and graph structure\nVisualization: Creates a GraphMakie plot with specified styling and layout\n\nThe resulting graph reveals the structure of the Collatz conjecture, showing:\n\nHow numbers flow through the conjecture's rules\nConnected components and convergence patterns\nThe overall network structure of number relationships\n\nLayout Options\n\n\"ClosestPacking\": Uses stress-based layout for compact visualization\n\"Spring\": Uses spring-force layout for natural node spacing\nOther layout algorithms supported by GraphMakie.jl\n\nPerformance Notes\n\nLabels are automatically disabled for graphs with >50 vertices for performance\nProgress indicators show generation status for large ranges\nStatistics provide insights into graph connectivity and structure\nMemory usage scales with the size of the largest numbers encountered\n\nGraph Properties\n\nThe function analyzes and reports:\n\nTotal number of unique vertices and edges\nConnected components and their sizes\nVertex range (smallest to largest numbers)\nPresence of key vertices (powers of 2)\n\nSee Also\n\ncollatz_sequence: Generate individual Collatz sequences\ncreate_collatz_visualization: Create path-based visualizations\ncreate_collatz_tree: Create tree-style visualizations\n\n\n\n\n\n","category":"function"},{"location":"#CollatzConjecture.collatz_graph_highlight_one","page":"Home","title":"CollatzConjecture.collatz_graph_highlight_one","text":"collatz_graph_highlight_one(range_end = 1000; kwargs...)\n\nCreate a directed graph visualization of Collatz sequences with vertex 1 specially highlighted.\n\nThis function generates Collatz sequences for all numbers from 1 to range_end, creates a graph visualization, and specially highlights vertex 1 (the convergence point of all Collatz sequences) with a distinct color, size, and label styling. All vertices can be optionally labeled to show their values.\n\nArguments\n\nrange_end = 1000: Upper limit of the range (generates sequences for 1:range_end)\n\nKeyword Arguments\n\nBasic Graph Styling\n\nvertex_style = RGBA(4/51, 51/51, 47/255, 0.8): Color and transparency of regular vertices\nedge_style = RGB(38/255, 139/255, 14/17): Color of graph edges\nvertex_size = 2: Size of regular vertex markers\nedge_width = 0.125: Width of edge lines\ngraph_layout = \"ClosestPacking\": Layout algorithm (\"ClosestPacking\", \"Spring\", etc.)\n\nVertex 1 Highlighting\n\nhighlight_color = RGB(1.0, 0.2, 0.2): Color for vertex 1 (bright red by default)\nhighlight_size = 15: Size of vertex 1 marker (much larger than regular vertices)\n\nLabeling Controls\n\nshow_all_labels = true: Whether to show labels on all vertices\nmax_labeled_vertices = 50: Maximum number of vertices to label (performance limit)\nlabel_fontsize = 14: Font size for vertex labels\nother_label_color = RGB(1.0, 1.0, 1.0): Color for labels on non-highlighted vertices\n\nOutput Control\n\nprint_stats = true: Whether to print detailed statistics about the graph\n\nReturns\n\nTuple{Figure, SimpleDiGraph, Vector{Int}, Vector{Tuple{Int,Int}}}: \nfig: Makie Figure containing the graph visualization\ng: The directed graph object from Graphs.jl\nvertices: Vector of all unique vertices in the graph\nedges: Vector of all directed edges as (source, destination) tuples\n\nExamples\n\n# Create highlighted graph with default settings\nfig, graph, vertices, edges = collatz_graph_highlight_one(100)\n\n# Create graph with custom highlight styling\nfig, graph, vertices, edges = collatz_graph_highlight_one(50,\n    highlight_color = RGB(1.0, 1.0, 0.0),  # Yellow highlight\n    highlight_size = 20,\n    label_fontsize = 12\n)\n\n# Create large graph with limited labeling\nfig, graph, vertices, edges = collatz_graph_highlight_one(1000,\n    show_all_labels = true,\n    max_labeled_vertices = 100,\n    vertex_size = 1,\n    edge_width = 0.1\n)\n\n# Create minimal graph with only vertex 1 labeled\nfig, graph, vertices, edges = collatz_graph_highlight_one(200,\n    show_all_labels = false,\n    vertex_style = RGBA(0.3, 0.3, 0.3, 0.5)\n)\n\nDetails\n\nThe highlighting visualization process:\n\nSequence Generation: Creates Collatz sequences for all numbers 1 to range_end\nGraph Construction: Builds directed graph with vertices and edges\nLayout Computation: Calculates vertex positions using specified algorithm\nSpecial Highlighting: Identifies vertex 1 and applies special styling\nLayered Rendering: Draws edges first, then vertices, then labels for optimal appearance\nSmart Labeling: Labels all vertices up to the specified limit, with special styling for vertex 1\n\nThe function emphasizes the central role of vertex 1 in the Collatz conjecture by:\n\nUsing a bright, contrasting color (red by default)\nMaking vertex 1 significantly larger than other vertices\nApplying special label formatting (white text with black outline)\nEnsuring vertex 1 remains visible even in large graphs\n\nHighlighting Features\n\nVertex 1 Detection: Automatically locates and highlights vertex 1 if present\nLayered Rendering: Uses separate graph plot calls for edges and vertices for cleaner appearance\nAdaptive Labeling: Shows all labels up to the limit, but always prioritizes vertex 1's label\nSpecial Typography: Vertex 1 gets larger font size and enhanced stroke for visibility\n\nPerformance Considerations\n\nLabels are automatically limited to max_labeled_vertices for performance\nFor graphs exceeding the label limit, only vertex 1 is labeled\nProgress indicators show generation status for large ranges\nMemory usage scales with the largest numbers encountered in sequences\n\nVisual Design\n\nThe function uses a layered approach:\n\nTransparent nodes with visible edges (base structure)\nColored nodes on top (vertex highlighting)\nText labels as the top layer (readability)\n\nThis ensures vertex 1's highlight is clearly visible while maintaining graph structure clarity.\n\nSee Also\n\ncollatz_graph: Create standard Collatz graph without highlighting\ncollatz_sequence: Generate individual Collatz sequences\ncreate_collatz_visualization: Create path-based visualizations\ncreate_collatz_tree: Create tree-style visualizations\n\n\n\n\n\n","category":"function"},{"location":"#CollatzConjecture.collatz_length-Tuple{Any}","page":"Home","title":"CollatzConjecture.collatz_length","text":"collatz_length(n)\n\nCalculate the length of the Collatz sequence for a given positive integer.\n\nThe Collatz sequence (also known as the 3n+1 problem or hailstone sequence) is generated by repeatedly applying the following rules:\n\nIf the number is even: divide by 2  \nIf the number is odd: multiply by 3 and add 1\nContinue until reaching 1\n\nThis function counts the total number of steps in the sequence, including the final 1.\n\nArguments\n\nn::Integer: A positive integer to start the Collatz sequence\n\nReturns\n\nInteger: The total length of the Collatz sequence (number of terms including the starting number and final 1)\n\nExamples\n\njulia> collatz_length(1)\n1\n\njulia> collatz_length(3)\n8\n\njulia> collatz_length(4)\n3\n\njulia> collatz_length(7)\n17\n\njulia> collatz_length(16)\n5\n\nNotes\n\nThe Collatz conjecture states that this sequence will always eventually reach 1 for any positive integer, though this has not been proven for all numbers.\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.collatz_paths-NTuple{4, Any}","page":"Home","title":"CollatzConjecture.collatz_paths","text":"collatz_paths(numbers, e, a, f)\n\nGenerate Collatz angle paths for multiple starting numbers.\n\nThis is a vectorized version of collatz_angle_path that processes multiple starting  numbers simultaneously, returning an array of paths.\n\nArguments\n\nnumbers: Collection of positive integers to use as starting values for Collatz sequences\ne: Exponent parameter for radius calculation (applied to all paths)\na: Angle scaling factor (applied to all paths)\nf: Angle offset factor (applied to all paths)\n\nReturns\n\nArray of paths, where each path is an array of (x, y) coordinate tuples\n\nExamples\n\n# Generate paths for numbers 3, 5, and 7\npaths = collatz_paths([3, 5, 7], 0.5, π/4, 1.0)\n\n# Generate paths for a range of numbers\npaths = collatz_paths(1:10, 0.3, π/6, 1.5)\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.collatz_sequence-Tuple{Any}","page":"Home","title":"CollatzConjecture.collatz_sequence","text":"collatz_sequence(n::Integer) -> Vector{Int}\n\nGenerate the complete Collatz sequence starting from a given positive integer.\n\nThe Collatz conjecture states that for any positive integer n, repeatedly applying the rule (n/2 if even, 3n+1 if odd) will eventually reach 1. This function returns the entire sequence from the starting number to 1.\n\nArguments\n\nn::Integer: Starting positive integer (must be > 0)\n\nReturns\n\nVector{Int}: Complete sequence from n to 1 (inclusive)\n\nExamples\n\njulia> collatz_sequence(3)\n8-element Vector{Int64}:\n 3\n 10\n 5\n 16\n 8\n 4\n 2\n 1\n\njulia> collatz_sequence(7)\n17-element Vector{Int64}:\n 7\n 22\n 11\n 34\n 17\n 52\n 26\n 13\n 40\n 20\n 10\n 5\n 16\n 8\n 4\n 2\n 1\n\njulia> length(collatz_sequence(27))\n112\n\nNotes\n\nThe conjecture remains unproven, but has been verified for very large numbers\nSome sequences can become quite long before reaching 1\nThe function will run indefinitely if the conjecture is false for the input\n\nThrows\n\nArgumentError: if n ≤ 0\n\nSee Also\n\nWikipedia: Collatz conjecture\nOEIS A006577: Number of steps in Collatz sequence\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.collatz_stopping_time-Tuple{Any}","page":"Home","title":"CollatzConjecture.collatz_stopping_time","text":"collatz_stopping_time(n)\n\nCalculate the stopping time of the Collatz sequence for a given positive integer.\n\nThe stopping time is the number of steps required to reach 1 from the starting number n in the Collatz sequence. The Collatz sequence is generated by repeatedly applying:\n\nIf the number is even: divide by 2  \nIf the number is odd: multiply by 3 and add 1\nContinue until reaching 1\n\nThis function counts only the transformation steps, excluding the final 1.\n\nArguments\n\nn::Integer: A positive integer to start the Collatz sequence\n\nReturns\n\nInteger: The number of steps required to reach 1 (stopping time)\n\nExamples\n\njulia> collatz_stopping_time(1)\n0\n\njulia> collatz_stopping_time(2)\n1\n\njulia> collatz_stopping_time(3)\n7\n\njulia> collatz_stopping_time(4)\n2\n\njulia> collatz_stopping_time(7)\n16\n\njulia> collatz_stopping_time(16)\n4\n\nNotes\n\nThe stopping time differs from sequence length by not counting the starting number or final 1. For example, the sequence 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 has stopping time 7.\n\nSee also: collatz_length\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.create_collatz_tree-Tuple{}","page":"Home","title":"CollatzConjecture.create_collatz_tree","text":"create_collatz_tree(; kwargs...)\n\nCreate a tree-like visualization of Collatz sequences as colored angle paths with vertex labels.\n\nThis function generates Collatz sequences, converts them to geometric paths, and creates a Makie.jl tree visualization with gradient colors and labeled vertices showing the actual Collatz numbers. The tree structure emphasizes the branching nature of Collatz sequences when visualized from their common convergence point.\n\nKeyword Arguments\n\nColor Parameters\n\ns = 2.49: Saturation parameter for color generation\nr = 0.76: Red component parameter for color generation\nh = 1.815: Hue parameter for color generation\ng = 1.3: Green component parameter for color generation\nopacity = 0.5: Transparency level for path lines (0.0 to 1.0)\n\nStructure Parameters\n\ne = 1.3: Exponent parameter for radius calculation in path generation\na = 0.19: Angle scaling factor for path generation\nf = 0.7: Angle offset factor for path generation\n\nNumber Selection\n\nn = 5: Number of sequences to generate (kept small for tree readability)\nuse_range = false: Whether to use a specific range instead of random numbers\nrange_start = 1: Starting number for range (used when use_range = true)\nrange_end = 5000: Ending number for range (used when use_range = true)\n\nVisualization Parameters\n\nlabel_fontsize = 8: Font size for vertex labels\nlabel_color = :white: Color of vertex labels\nshow_vertex_dots = true: Whether to show dots at vertices\nvertex_size = 8: Size of vertex dots/markers\nmax_label_length = 50: Maximum number of labels per path (for long sequences)\n\nOutput Control\n\nprint_numbers = false: Whether to print the numbers being processed\n\nReturns\n\nFigure: A Makie.jl Figure object containing the tree visualization\n\nExamples\n\n# Create tree visualization with default parameters\nfig = create_collatz_tree()\n\n# Create tree for specific numbers with larger vertices\nfig = create_collatz_tree(\n    use_range=true, range_start=10, range_end=15,\n    vertex_size=12, label_fontsize=10\n)\n\n# Create minimal tree without vertex dots\nfig = create_collatz_tree(\n    n=3, show_vertex_dots=false, label_color=:cyan\n)\n\n# Create tree with custom structure parameters\nfig = create_collatz_tree(\n    e=1.5, a=0.25, f=0.8, vertex_size=6\n)\n\nDetails\n\nThe tree visualization process:\n\nGenerates a set of numbers (smaller range for readability)\nComputes Collatz sequences and their corresponding angle paths\nCreates paths that emanate from a common origin (representing convergence to 1)\nPlots each branch as colored line segments with gradient colors\nAdds configurable vertex markers at sequence points\nLabels vertices with their corresponding Collatz numbers\nUses black vertex dots to emphasize the tree structure\n\nThe tree structure becomes apparent as multiple Collatz sequences are displayed simultaneously, showing how different starting numbers create branching paths that all converge to the same point. The vertex_size parameter allows for customization of the node prominence in the tree structure.\n\nNotes\n\nUses black vertex dots (instead of yellow) to emphasize tree node structure\nVertex size is configurable to enhance tree visualization aesthetics\nBest viewed with smaller numbers of sequences (3-10) for clear tree structure\nAll sequences share the common convergence point at the origin\n\nSee Also\n\ncreate_collatz_with_labels: Create labeled Collatz paths\ncreate_collatz_visualization: Create unlabeled Collatz visualization\ncollatz_paths: Generate multiple Collatz angle paths\ngenerate_path_colors: Generate colors for path visualization\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.create_collatz_visualization-Tuple{}","page":"Home","title":"CollatzConjecture.create_collatz_visualization","text":"create_collatz_visualization(; kwargs...)\n\nCreate a visualization of Collatz sequences as colored angle paths.\n\nThis function generates multiple Collatz sequences, converts them to geometric paths, and creates a Makie.jl visualization with gradient colors along each path.\n\nKeyword Arguments\n\nColor Parameters\n\ns = 2.49: Saturation parameter for color generation\nr = 0.76: Red component parameter for color generation\nh = 1.815: Hue parameter for color generation\ng = 1.3: Green component parameter for color generation\nopacity = 0.5: Transparency level for path lines (0.0 to 1.0)\n\nStructure Parameters\n\ne = 1.3: Exponent parameter for radius calculation in path generation\na = 0.19: Angle scaling factor for path generation\nf = 0.7: Angle offset factor for path generation\n\nNumber Selection\n\nn = 300: Number of random sequences to generate (used when use_range = false)\nuse_range = false: Whether to use a specific range instead of random numbers\nrange_start = 5000: Starting number for range (used when use_range = true)\nrange_end = 5020: Ending number for range (used when use_range = true)\n\nOutput Control\n\nprint_numbers = false: Whether to print the numbers being processed\n\nReturns\n\nFigure: A Makie.jl Figure object containing the visualization\n\nExamples\n\n# Create visualization with default parameters\nfig = create_collatz_visualization()\n\n# Create visualization with custom color parameters\nfig = create_collatz_visualization(s=3.0, r=0.8, opacity=0.7)\n\n# Create visualization for a specific range of numbers\nfig = create_collatz_visualization(use_range=true, range_start=100, range_end=150)\n\n# Create visualization with verbose output\nfig = create_collatz_visualization(n=50, print_numbers=true)\n\nDetails\n\nThe visualization process:\n\nGenerates a set of numbers (either random or from a specified range)\nComputes Collatz angle paths for each number\nCreates a transparent-background figure with hidden axes\nPlots each path as colored line segments with gradient colors\nAuto-scales the view to fit all paths\n\nEach path is colored using the generate_path_colors function with astronomical intensity mapping, creating smooth color transitions along the sequence.\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.create_collatz_with_labels-Tuple{}","page":"Home","title":"CollatzConjecture.create_collatz_with_labels","text":"create_collatz_with_labels(; kwargs...)\n\nCreate a visualization of Collatz sequences as colored angle paths with vertex labels.\n\nThis function generates Collatz sequences, converts them to geometric paths, and creates a Makie.jl visualization with gradient colors and labeled vertices showing the actual Collatz numbers at each point along the path.\n\nKeyword Arguments\n\nColor Parameters\n\ns = 2.49: Saturation parameter for color generation\nr = 0.76: Red component parameter for color generation\nh = 1.815: Hue parameter for color generation\ng = 1.3: Green component parameter for color generation\nopacity = 0.5: Transparency level for path lines (0.0 to 1.0)\n\nStructure Parameters\n\ne = 1.3: Exponent parameter for radius calculation in path generation\na = 0.19: Angle scaling factor for path generation\nf = 0.7: Angle offset factor for path generation\n\nNumber Selection\n\nn = 5: Number of sequences to generate (kept small for label readability)\nuse_range = false: Whether to use a specific range instead of random numbers\nrange_start = 1: Starting number for range (used when use_range = true)\nrange_end = 5000: Ending number for range (used when use_range = true)\n\nLabel Parameters\n\nlabel_fontsize = 8: Font size for vertex labels\nlabel_color = :white: Color of vertex labels\nshow_vertex_dots = true: Whether to show dots at vertices\nmax_label_length = 50: Maximum number of labels per path (for long sequences)\n\nOutput Control\n\nprint_numbers = false: Whether to print the numbers being processed\n\nReturns\n\nFigure: A Makie.jl Figure object containing the labeled visualization\n\nExamples\n\n# Create labeled visualization with default parameters\nfig = create_collatz_with_labels()\n\n# Create visualization for specific numbers with custom labels\nfig = create_collatz_with_labels(\n    use_range=true, range_start=7, range_end=12,\n    label_fontsize=10, label_color=:cyan\n)\n\n# Create visualization with fewer labels for cleaner appearance\nfig = create_collatz_with_labels(\n    n=3, max_label_length=20, show_vertex_dots=false\n)\n\n# Create visualization with verbose output\nfig = create_collatz_with_labels(n=5, print_numbers=true)\n\nDetails\n\nThe labeled visualization process:\n\nGenerates a set of numbers (smaller range for readability)\nComputes Collatz sequences and their corresponding angle paths\nCreates a transparent-background figure with hidden axes\nPlots each path as colored line segments with gradient colors\nAdds vertex dots at sequence points (optional)\nLabels each vertex with its corresponding Collatz number\nFor very long sequences, samples labels to maintain readability\n\nThe labeling system ensures that each Collatz number is positioned at its correct geometric location along the path. For sequences longer than max_label_length, the function intelligently samples vertices while always including the first and last numbers.\n\nNotes\n\nUses smaller default numbers (10-100) compared to the unlabeled version for better readability\nLabels are offset slightly below vertices to avoid overlap with dots\nVery long sequences are automatically subsampled to prevent overcrowding\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.generate_path_colors-NTuple{5, Any}","page":"Home","title":"CollatzConjecture.generate_path_colors","text":"generate_path_colors(path_length, s, r, h, g)\n\nGenerate colors for a path using astronomical intensity mapping.\n\nArguments\n\npath_length: Number of points in the path\ns: Saturation parameter for astro_intensity function\nr: Red component parameter for astro_intensity function  \nh: Hue parameter for astro_intensity function\ng: Green component parameter for astro_intensity function\n\nReturns\n\nArray of RGB colors interpolated along the path length\n\nExamples\n\ncolors = generate_path_colors(10, 0.8, 1.0, 0.5, 0.7)\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.plot_stopping_times_histogram","page":"Home","title":"CollatzConjecture.plot_stopping_times_histogram","text":"plot_stopping_times_histogram(max_n::Int=1000)\n\nCreate a dual-axis histogram and cumulative distribution plot of Collatz stopping times.\n\nThis function calculates stopping times for all numbers from 1 to max_n and creates a sophisticated visualization combining a frequency histogram (left y-axis) with a cumulative distribution function (right y-axis) to reveal both the distribution shape and cumulative probability patterns.\n\nArguments\n\nmax_n::Int=1000: Maximum number to analyze (default: 1000)\n\nReturns\n\nFigure: A Makie.jl Figure object containing the dual-axis histogram visualization\n\nExamples\n\n# Create default histogram for numbers 1-1000\nfig = plot_stopping_times_histogram()\n\n# Analyze distribution for smaller range with more detail\nfig = plot_stopping_times_histogram(500)\n\n# Study larger range to capture more statistical variation\nfig = plot_stopping_times_histogram(10000)\n\n# Save the analysis\nsave(\"stopping_times_distribution.png\", fig)\n\nVisualization Features\n\nHistogram (Left Y-Axis)\n\nBlue bars: Frequency distribution of stopping times across 50 bins\nBlack outlines: Clear bin boundaries for precise reading\nHigh transparency: 99% opacity for professional appearance\nFrequency counts: Left y-axis shows absolute number of occurrences\n\nCumulative Distribution (Right Y-Axis)\n\nPink line: Cumulative distribution function (CDF) showing probability\nSmooth curve: Reveals percentile information and distribution shape\nSecondary axis: Right y-axis shows cumulative probability (0.0 to 1.0)\nThick line: High visibility for trend analysis\n\nProfessional Styling\n\nTransparent background: Suitable for presentations and publications\nLarge text: All labels use size 20 for excellent readability\nColor coordination: Blue for frequency, pink for probability\nLinked x-axes: Both plots share the same stopping time scale\n\nStatistical Insights Revealed\n\nDistribution Shape\n\nSkewness: Most stopping times are small, with a long right tail\nModal behavior: Most common stopping times (highest bars)\nOutliers: Very large stopping times appear as sparse bins on the right\nConcentration: How stopping times cluster around typical values\n\nCumulative Patterns\n\nPercentiles: Easy to read what percentage of numbers have stopping times ≤ x\nMedian identification: 50% cumulative probability point\nQuartiles: 25% and 75% probability thresholds\nTail behavior: How quickly probability approaches 100%\n\nMathematical Applications\n\nResearch Analysis\n\n# Compare distributions across different ranges\nfig1 = plot_stopping_times_histogram(1000)\nfig2 = plot_stopping_times_histogram(5000)\n# Analyze how distribution shape changes with sample size\n\nEducational Use\n\nProbability education: Demonstrates histogram vs. CDF concepts\nStatistical analysis: Shows real-world example of skewed distributions\nCollatz conjecture: Visualizes the unpredictable nature of stopping times\n\nTechnical Implementation\n\nHistogram Computation\n\nAdaptive binning: Uses 50 bins automatically scaled to data range\nFrequency counting: Efficient computation of bin heights\nProfessional styling: Consistent with statistical visualization standards\n\nCDF Calculation\n\nSorted processing: Efficiently computes cumulative probabilities\nUnique values: Handles repeated stopping times correctly\nSmooth interpolation: Creates visually appealing probability curve\n\nPerformance Characteristics\n\nTime complexity: O(n log n) due to sorting for CDF\nSpace complexity: O(n) for storing computed values\nMemory efficient: Single-pass histogram computation\nScalable: Handles large ranges (tested up to 100,000+)\n\nInterpretation Guide\n\nReading the Histogram\n\nPeak locations: Most common stopping times\nDistribution width: Spread of typical stopping times\nTail length: Range of extreme stopping times\n\nReading the CDF\n\nSteep sections: Ranges where many stopping times occur\nFlat sections: Ranges with few or no stopping times\n50% point: Median stopping time\n90% point: 90th percentile (most numbers have shorter stopping times)\n\nData Quality Features\n\nAutomatic formatting: Integer labels for counts, decimal for probabilities\nColor coding: Distinct colors prevent confusion between axes\nLegend: Clear identification of the CDF line\nProfessional presentation: Publication-ready styling\n\nSee Also\n\ncalculate_stopping_times: Compute stopping times for analysis\nplot_stopping_times_scatter: Scatter plot visualization\nstopping_time: Calculate individual stopping times\ncollatz_sequence: Generate complete sequences\n\n\n\n\n\n","category":"function"},{"location":"#CollatzConjecture.plot_stopping_times_scatter","page":"Home","title":"CollatzConjecture.plot_stopping_times_scatter","text":"plot_stopping_times_scatter(max_n::Int=1000)\n\nCreate a scatter plot visualization of Collatz stopping times with a moving average trend line.\n\nThis function calculates stopping times for all numbers from 1 to max_n and creates a scatter plot showing the relationship between starting numbers and their stopping times. A red moving average line reveals overall trends in the data.\n\nArguments\n\nmax_n::Int=1000: Maximum number to analyze (default: 1000)\n\nReturns\n\nFigure: A Makie.jl Figure object containing the scatter plot visualization\n\nExamples\n\n# Create default plot for numbers 1-1000\nfig = plot_stopping_times_scatter()\n\n# Plot for a smaller range with more detail\nfig = plot_stopping_times_scatter(100)\n\n# Plot for a larger range to see broader patterns\nfig = plot_stopping_times_scatter(5000)\n\n# Save the plot\nsave(\"stopping_times.png\", fig)\n\nVisualization Features\n\nScatter Plot Elements\n\nBlue points: Each point represents one number and its stopping time\nTransparency: Points have 90% opacity to show overlapping patterns\nPoint size: Small markers (size 3) to avoid overcrowding\n\nTrend Analysis\n\nMoving average: Red line showing smoothed trends across the data\nWindow size: Automatically scaled as max_n ÷ 50 for appropriate smoothing\nLegend: Shows the moving average line identification\n\nStyling\n\nTransparent background: Suitable for presentations and documents\nLarge text: All labels and titles use size 20 for readability\nProfessional formatting: Clean axis styling with appropriate tick formatting\n\nPatterns Revealed\n\nThe visualization typically shows:\n\nIrregular spikes: Some numbers have much longer stopping times than neighbors\nGeneral trends: Moving average reveals whether stopping times increase with number size\nPower-of-2 pattern: Numbers that are powers of 2 show predictable stepping\nClustering effects: Groups of numbers with similar stopping times\nOutliers: Numbers with exceptionally long stopping times stand out clearly\n\nMathematical Insights\n\nThe plot helps identify:\n\nRecord holders: Numbers with locally maximum stopping times\nDistribution shape: Whether stopping times follow any predictable pattern\nGrowth behavior: How stopping times scale with input size\nVariance patterns: Regions of high vs. low variability\n\nTechnical Details\n\nMoving average calculation: Uses symmetric window around each point\nWindow boundaries: Handles edge cases at the beginning and end of data\nAutomatic scaling: Window size adapts to data range for optimal smoothing\nMemory efficient: Processes data in a single pass\n\nCustomization Options\n\nWhile this function provides a standard visualization, you can modify the returned figure:\n\nfig = plot_stopping_times_scatter(1000)\n# Modify colors, add annotations, etc.\nax = fig[1, 1]\n# Add additional analysis or annotations\n\nPerformance Notes\n\nComputation time scales with max_n\nFor max_n > 10,000, consider computing in batches\nThe moving average calculation is O(n) efficient\nMemory usage grows linearly with the number of data points\n\nUse Cases\n\nEducational demonstrations of Collatz conjecture behavior\nResearch analysis of stopping time patterns\nStatistical exploration of number theory properties\nPresentation graphics for mathematical talks\nComparative analysis across different ranges\n\nSee Also\n\ncalculate_stopping_times: Compute stopping times for analysis\nstopping_time: Calculate individual stopping times\ncollatz_sequence: Generate complete sequences\ncreate_collatz_visualization: Alternative visualization approaches\n\n\n\n\n\n","category":"function"},{"location":"#CollatzConjecture.stopping_time-Tuple{Int64}","page":"Home","title":"CollatzConjecture.stopping_time","text":"stopping_time(n::Int)\n\nCalculate the stopping time (total number of steps) for a Collatz sequence starting from n.\n\nThe stopping time is the number of iterations required for a Collatz sequence to reach 1. This function applies the standard Collatz rules: if n is even, divide by 2; if n is odd, multiply by 3 and add 1. The process continues until reaching 1.\n\nArguments\n\nn::Int: Starting positive integer for the Collatz sequence\n\nReturns\n\nInt: Number of steps to reach 1, or special values:\n0: If input is ≤ 0 (invalid input)\n-1: If sequence exceeds 10,000 steps (potential infinite loop protection)\n\nExamples\n\n# Calculate stopping time for small numbers\nstopping_time(1)    # Returns 0 (already at 1)\nstopping_time(2)    # Returns 1 (2 → 1)\nstopping_time(3)    # Returns 7 (3 → 10 → 5 → 16 → 8 → 4 → 2 → 1)\nstopping_time(4)    # Returns 2 (4 → 2 → 1)\n\n# Calculate stopping time for larger numbers\nstopping_time(27)   # Returns 111 (known to have a long sequence)\nstopping_time(100)  # Returns 25\n\n# Edge cases\nstopping_time(0)    # Returns 0 (invalid input)\nstopping_time(-5)   # Returns 0 (invalid input)\n\nDetails\n\nThe function implements the standard Collatz conjecture iteration:\n\nIf n is even: n → n/2\nIf n is odd: n → 3n + 1\nContinue until n = 1\n\nThe stopping time provides insight into the complexity of different starting numbers:\n\nPowers of 2 have predictable stopping times: 2^k has stopping time k\nOdd numbers often have longer and less predictable stopping times\nSome numbers (like 27) are known to have surprisingly long sequences\n\nSafety Features\n\nInput validation: Returns 0 for non-positive inputs\nInfinite loop protection: Returns -1 if more than 10,000 steps are required\nOverflow protection: Uses integer division to prevent unnecessary growth\n\nPerformance Notes\n\nTime complexity: O(s) where s is the stopping time\nSpace complexity: O(1) - only tracks the current number and step count\nThe 10,000 step limit prevents runaway computations while allowing most legitimate sequences\n\nMathematical Context\n\nThe stopping time is a key measure in Collatz conjecture research:\n\nThe conjecture states that all positive integers eventually reach 1\nNo counterexample has been found, but no proof exists\nStopping times exhibit complex, seemingly chaotic behavior\nThe distribution of stopping times is an active area of research\n\nSee Also\n\ncollatz_sequence: Generate the complete Collatz sequence\ncollatz_angle_path: Convert Collatz sequence to geometric path\ncreate_collatz_visualization: Visualize Collatz sequences\n\n\n\n\n\n","category":"method"},{"location":"#CollatzConjecture.test_collatz_connectivity","page":"Home","title":"CollatzConjecture.test_collatz_connectivity","text":"test_collatz_connectivity(max_n = 20)\n\nTest and analyze the connectivity of Collatz sequences for integers from 1 to max_n.\n\nThis function generates Collatz sequences for all integers from 1 to max_n and analyzes how they interconnect by finding shared vertices (numbers that appear in multiple sequences). It provides insights into the tree-like structure of the Collatz conjecture.\n\nArguments\n\nmax_n::Integer: Maximum starting number to test (default: 20)\n\nReturns\n\nTuple: A tuple containing:\nsequences: Vector of tuples (n, sequence) for each starting number\nvertex_counts: Dictionary mapping each vertex to the sequences that contain it\n\nExamples\n\njulia> sequences, vertex_counts = test_collatz_connectivity(5);\n=== Testing Collatz sequence connectivity ===\n1: [1] (length: 1)\n2: [2, 1] (length: 2)\n3: [3, 10, 5, 16, 8, 4, 2, 1] (length: 8)\n4: [4, 2, 1] (length: 3)\n5: [5, 16, 8, 4, 2, 1] (length: 6)\n\nAll unique vertices: [1, 2, 3, 4, 5, 8, 10, 16]\n\nShared vertices (vertex -> sequences that contain it):\n 1 appears in sequences: [1, 2, 3, 4, 5]\n 2 appears in sequences: [2, 3, 4, 5]\n 4 appears in sequences: [3, 4, 5]\n 8 appears in sequences: [3, 5]\n 16 appears in sequences: [3, 5]\n\njulia> test_collatz_connectivity(10);\n\nNotes\n\nThis function demonstrates the tree-like structure of Collatz sequences, where different starting numbers eventually merge into common paths. All sequences eventually reach 1, supporting the Collatz conjecture for the tested range.\n\nThe function requires collatz_sequence(n) to be defined, which should return the complete Collatz sequence starting from n.\n\nSee also: collatz_sequence, collatz_length, collatz_stopping_time\n\n\n\n\n\n","category":"function"}]
}
