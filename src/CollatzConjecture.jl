module CollatzConjecture

include("visualizations/plotting.jl")

export astro_intensity

# Write your package code here.
# Export the main function so users can access it directly
export collatz_sequence, collatz_length, collatz_stopping_time, test_collatz_connectivity

"""
    collatz_sequence(n::Integer) -> Vector{Int}

Generate the complete Collatz sequence starting from a given positive integer.

The Collatz conjecture states that for any positive integer n, repeatedly applying
the rule (n/2 if even, 3n+1 if odd) will eventually reach 1. This function
returns the entire sequence from the starting number to 1.

# Arguments
- `n::Integer`: Starting positive integer (must be > 0)

# Returns
- `Vector{Int}`: Complete sequence from n to 1 (inclusive)

# Examples
```julia
julia> collatz_sequence(3)
8-element Vector{Int64}:
 3
 10
 5
 16
 8
 4
 2
 1

julia> collatz_sequence(7)
17-element Vector{Int64}:
 7
 22
 11
 34
 17
 52
 26
 13
 40
 20
 10
 5
 16
 8
 4
 2
 1

julia> length(collatz_sequence(27))
112
```

# Notes
- The conjecture remains unproven, but has been verified for very large numbers
- Some sequences can become quite long before reaching 1
- The function will run indefinitely if the conjecture is false for the input

# Throws
- `ArgumentError`: if n ≤ 0

# See Also
- Wikipedia: Collatz conjecture
- OEIS A006577: Number of steps in Collatz sequence
"""
function collatz_sequence(n)
    # Input validation
    if n ≤ 0
        throw(ArgumentError("Input must be a positive integer, got: $n"))
    end
    
    sequence = Int[]
    nn = n
    
    while nn != 1
        push!(sequence, nn)
        nn = iseven(nn) ? nn ÷ 2 : 3*nn + 1
    end
    
    # Add the final 1
    push!(sequence, nn)
    
    return sequence
end

"""
    collatz_length(n)

Calculate the length of the Collatz sequence for a given positive integer.

The Collatz sequence (also known as the 3n+1 problem or hailstone sequence) is generated
by repeatedly applying the following rules:
- If the number is even: divide by 2  
- If the number is odd: multiply by 3 and add 1
- Continue until reaching 1

This function counts the total number of steps in the sequence, including the final 1.

# Arguments
- `n::Integer`: A positive integer to start the Collatz sequence

# Returns
- `Integer`: The total length of the Collatz sequence (number of terms including the starting number and final 1)

# Examples
```julia-repl
julia> collatz_length(1)
1

julia> collatz_length(3)
8

julia> collatz_length(4)
3

julia> collatz_length(7)
17

julia> collatz_length(16)
5
```

# Notes
The Collatz conjecture states that this sequence will always eventually reach 1 for any positive integer,
though this has not been proven for all numbers.
"""
function collatz_length(n)
    length = 0
    nn = n
    while nn != 1
        length += 1
        nn = iseven(nn) ? nn ÷ 2 : 3*nn + 1
    end
    return length + 1  # +1 to include the final 1
end

"""
    collatz_stopping_time(n)

Calculate the stopping time of the Collatz sequence for a given positive integer.

The stopping time is the number of steps required to reach 1 from the starting number n
in the Collatz sequence. The Collatz sequence is generated by repeatedly applying:
- If the number is even: divide by 2  
- If the number is odd: multiply by 3 and add 1
- Continue until reaching 1

This function counts only the transformation steps, excluding the final 1.

# Arguments
- `n::Integer`: A positive integer to start the Collatz sequence

# Returns
- `Integer`: The number of steps required to reach 1 (stopping time)

# Examples
```julia-repl
julia> collatz_stopping_time(1)
0

julia> collatz_stopping_time(2)
1

julia> collatz_stopping_time(3)
7

julia> collatz_stopping_time(4)
2

julia> collatz_stopping_time(7)
16

julia> collatz_stopping_time(16)
4
```

# Notes
The stopping time differs from sequence length by not counting the starting number or final 1.
For example, the sequence 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 has stopping time 7.

See also: [`collatz_length`](@ref)
"""
function collatz_stopping_time(n)
    steps = 0
    nn = n
    while nn != 1
        steps += 1
        nn = iseven(nn) ? nn ÷ 2 : 3*nn + 1
    end
    return steps
end

"""
    test_collatz_connectivity(max_n = 20)

Test and analyze the connectivity of Collatz sequences for integers from 1 to max_n.

This function generates Collatz sequences for all integers from 1 to max_n and analyzes
how they interconnect by finding shared vertices (numbers that appear in multiple sequences).
It provides insights into the tree-like structure of the Collatz conjecture.

# Arguments
- `max_n::Integer`: Maximum starting number to test (default: 20)

# Returns
- `Tuple`: A tuple containing:
  - `sequences`: Vector of tuples (n, sequence) for each starting number
  - `vertex_counts`: Dictionary mapping each vertex to the sequences that contain it

# Examples
```julia-repl
julia> sequences, vertex_counts = test_collatz_connectivity(5);
=== Testing Collatz sequence connectivity ===
1: [1] (length: 1)
2: [2, 1] (length: 2)
3: [3, 10, 5, 16, 8, 4, 2, 1] (length: 8)
4: [4, 2, 1] (length: 3)
5: [5, 16, 8, 4, 2, 1] (length: 6)

All unique vertices: [1, 2, 3, 4, 5, 8, 10, 16]

Shared vertices (vertex -> sequences that contain it):
 1 appears in sequences: [1, 2, 3, 4, 5]
 2 appears in sequences: [2, 3, 4, 5]
 4 appears in sequences: [3, 4, 5]
 8 appears in sequences: [3, 5]
 16 appears in sequences: [3, 5]

julia> test_collatz_connectivity(10);
```

# Notes
This function demonstrates the tree-like structure of Collatz sequences, where different
starting numbers eventually merge into common paths. All sequences eventually reach 1,
supporting the Collatz conjecture for the tested range.

The function requires `collatz_sequence(n)` to be defined, which should return the
complete Collatz sequence starting from n.

See also: [`collatz_sequence`](@ref), [`collatz_length`](@ref), [`collatz_stopping_time`](@ref)
"""
function test_collatz_connectivity(max_n = 20)
    println("=== Testing Collatz sequence connectivity ===")
    # Generate a few sequences and show how they connect
    sequences = []
    for n in 1:max_n
        seq = collatz_sequence(n)
        push!(sequences, (n, seq))
        println("$n: $(seq) (length: $(length(seq)))")
    end
    
    # Find shared vertices
    all_vertices = Set{Int}()
    for (n, seq) in sequences
        for v in seq
            push!(all_vertices, v)
        end
    end
    println("\nAll unique vertices: $(sort(collect(all_vertices)))")
    
    # Show which sequences share which vertices
    vertex_counts = Dict{Int, Vector{Int}}()
    for (n, seq) in sequences
        for v in seq
            if !haskey(vertex_counts, v)
                vertex_counts[v] = []
            end
            push!(vertex_counts[v], n)
        end
    end
    
    println("\nShared vertices (vertex -> sequences that contain it):")
    for v in sort(collect(keys(vertex_counts)))
        if length(vertex_counts[v]) > 1
            println("  $v appears in sequences: $(vertex_counts[v])")
        end
    end
    
    return sequences, vertex_counts
end


end # module CollatzConjecture


